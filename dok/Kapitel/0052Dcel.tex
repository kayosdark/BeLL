\section{Erstellen der DCEL}
\subsection{Graph Klasse}
Die wichtigste Klasse der Anwendung ist \icode{Graph}. 
Sie verbindet alle grafischen Bestandteile und kann mit einer übergebenen Liste aus Linien mittels mehrerer Zwischenoperationen eine vollständige DCEL, also einen planaren Graph erstellen.
Dafür sind drei Listen vom Typ \icode{Edge}(Kante), \icode{Node}(Knoten) und \icode{Face}(Fläche) gespeichert, die eine DCEL repräsentieren.
\subsection{Line-to-Edge Konvertierung}
\label{subsec:ltoe} 
Initialisierend werden die Start- und Endpunkte der eingelesenen Linien in Knoten ohne eine Referenz auf eine anliegende Kante umgewandelt und diese als Start- und Endknoten der entsprechenden Kante gesetzt.
Um für die Eindeutigkeit der Knoten zu sorgen, gibt die Funktion \icode{createNode()} ein äquivalenten Knoten zu einem Punkt zurück und fügt ihn zu der Liste an Knoten hinzu, wenn er noch nicht in ihr existiert.

\begin{code}[Line-to-Edge Konvertierung]
private void processData(ArrayList<Line> ls) {
	for (Line l : ls) {
		edges.add(new Edge(createNode(l.getP1()), createNode(l.getP2())));
	}
}
\end{code}
\begin{code}[\icode{createNode()} Funktion]
private Node createNode(Vector p) {
	for (Node n : nodes) {
		if (n.getOrigin().equals(p)) {
			return n;
		}
	}
	nodes.add(new Node(p));
	return (nodes.get(nodes.size() - 1));
}
\end{code}
\todoinline{Hier könnte man noch was zu sagen}
\subsection{Zwillingskantengenerierung}
Um aus den entstandenen Kanten die invertierten Gegenstücke, auch als \q{Zwillingskanten} bezeichnet, zu erhalten, werden alle Kanten, die in der Liste bereits vorhanden sind, betrachtet und neue Kanten hinzugefügt, die im Vergleich zu den ursprünglichen Kanten vertauschte Start- und Endknoten besitzen.
Direkt nach dem Hinzufügen der neuen Kante wird jeweils eine Referenz erstellt, die in beiden Kanten auf den jeweils zugehörigen Zwilling verweist. 
In der Kantenliste existiert nun für jede Linie die der DXF-Reader eingelesen hat, zwei zueinander komplementäre Kanten.
\begin{code}[Hinzufügen der Zwillingskanten]
private void computeTwins() {
	int amount = edges.size();
	for (int i = 0; i < amount; i++) {
		edges.add(edges.get(i).generateTwin());
		edges.get(i).setTwin(edges.get(edges.size() - 1));
		edges.get(edges.size() - 1).setTwin(edges.get(i));
	}
}
\end{code}
\subsection{Nachfolger- und Vorgängerermittlung}
Das Erstellen der Referenzen werden zuerst alle ausgehenden Edges der Nodes, das heißt alle Edges, die den jeweiligen Node als ihren Startnode besitzen, in einer zweidimensionalen ArrayList gespeichert.
Die erste Dimension steht für den Index des Nodes in der erstellten Nodeliste für den in der zweiten Dimension die jeweiligen ausgehenden Edges vorliegen.
Da diese durch eine \icode{for()} Schleife mit der oben stehenden Bedingung herausgesucht werden, sind die Edges im Array in zufälliger Reihenfolge, also nicht nach der Anordnung am Node gegenwärtig.
Jetzt werden die Edges anhand des \icode{atan2()} Winkel am vorliegenden Node im mathematisch positiven Drehsinn sortiert.
Daraus ergibt sich, dass das vorherige bzw. nachfolgende Element einer Edge die Edge, die \q{links} bzw. \q{rechts} der Betrachteten liegt darstellt.\\
Für jede ausgehende Edge \icode{e} können nun folgende Referenzen gesetzt werden:
\begin{itemize}
	\item Das vorherige bzw. letzte Element der ArrayList, wenn die betrachtete Edge den Index 0 hat, stellt den Nachfolger der Twinedge von \icode{e} dar.
	\item Der Twin der in der ArrayList nachfolgenden Edge bzw. ersten Edge, wenn die betrachtete Edge das letzte Element ist, ist der Vorgänger von \icode{e}
\end{itemize}
Genannte Referenzen werden nun gesetzt, sodass die Verknüpfungen zwischen den Edges fertiggestellt sind.
\todoinline{code eventuell bilder definitiv}
\subsection{Flächenerstellung}
Durch eine Schleife können die einzelnen Flächen herausgefiltert werden.
Es muss lediglich fortlaufend alle Nachfolger einer gewählten Kante herausgesucht werden bis die gewählte Kante einen Nachfolger darstellt, bis alle Kanten genau einmal behandelt wurden.
Dafür wurde eine repräsentative Boolean-ArrayList mit der Länge der Kantenliste erstellt, die mit ihren Werten den Status der Kanten darstellt.
Folglich besteht diese am Anfang nur aus \icode{false} Werten die während der Schleife alle auf \icode{true} gesetzt werden.
Die Speicherung der Faces folgt nach dem DCEL-Standard statt, sodass nur eine anliegende Kante zugewiesen wird, mit der man, aufgrund von den Referenzen zwischen den Kanten alle Kanten und Knoten der Fläche ermitteln kann.
Das äußere Gebiet des planaren Graphens lässt sich an der Umlaufrichtung der Kanten erkennen.
Es ist die einzige Fläche, die im mathematisch negativen Drehsinn ausgerichtet ist.
Unterschieden wird sie im weiteren Programmablauf mithilfe der gaußschen Trapezformel.
Bei negativer Umlaufrichtung ist das Ergebnis dieser negativ und lässt sich resultierend leicht erkennen.

\subsection{Vervollständigung der Knoten}
Die letzte nötige Operation ist die Speicherung einer anliegenden Edge in den Nodes.\todoinline{man könnte das im code auch vorher tun denke ich}