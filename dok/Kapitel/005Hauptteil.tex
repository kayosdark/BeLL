\chapter{Vorgehen zur Problemlösung}
\section{Einlesen des Grundrisses}
\subsection{Funktionsweise der Bibliothek \textit{kabeja}}
Den Beginn der Verarbeitung markiert hierbei die Grundrissdatei, in welcher sämtliche Werte, welche im weiteren Verlauf des Programmes relevant werden, enthalten sind.
Das Einlesen der Daten eines Grundrisses, wie in Abb. 5, erfolgt mit der Java-Bibliothek „kabeja“. 
Diese ermöglicht es, aus .dxf-Dateien alle DXF-Objekte eines bestimmten Typs zu erhalten und deren Werte in einer Liste zu speichern und später zu verarbeiten (vgl. Internetquelle 7).
\begin{code}
	public static ArrayList<Line> getAutocadFile
	(String filePath) throws ParseException {
			ArrayList<Line> vcs = new ArrayList<>();
		
			Parser parser =
				ParserBuilder.createDefaultParser();
			parser.parse(filePath,
		8	 		DXFParser.DEFAULT_ENCODING);
		9		DXFDocument doc = parser.getDocument();
		10	
		11		List lst = doc.getDXFLayer("0").
		12	 	 	getDXFEntities(
		13	 		DXFConstants.ENTITY_TYPE_LINE); 
		14		for (
		15	 	int index = 0; index < lst.size(); index++) {
			16			DXFLine dxfline =
			17	 		(DXFLine) lst.get(index);
			18	
			19	 		Line v = new Line(
			20			new Vector(
			21	 		round2(dxfline.getStartPoint().getX()), 
			22	 		round2(dxfline.getStartPoint().getY())),
			23			new Vector(
			24	 		round2(dxfline.getEndPoint().getX()), 
			25	 		round2(dxfline.getEndPoint().getY())));
			26			vcs.add(v);
			27		}
		28		return vcs;
		29	}

\end{code}

\begin{figure}
	\centering
	\includegraphics{example-image-a}
	\caption{Your figure}
%	\label{fig:a}
\end{figure}


In dieser Anwendung wird eine Funktion der Klasse „DXFReader“ verwendet, welche den Pfad zur .dxf-Datei als Parameter übergeben bekommt. 
Aus dieser Datei werden dann alle DXF-Objekte, die mit dem Typen „DXFLine“ übereinstimmen, in einer Liste zurückgegeben. 
Die Koordinaten der Start- und Endpunkte der DXFLines  in dieser Liste werden anschließend in eine Liste von Lines übertragen, welche im weiteren Programmablauf unter anderem für die Umwandlung des Graphen in die DCEL verwendet werden.
\subsection{Funktionsweise der GUI}
\todo{asdf}

\section{Erstellen der DCEL}
\subsection{Line-to-Edge Konvertierung}
In der Hauptklasse des Programms wird nun aus der Liste von Lines ein Graph erstellt. 
Zuerst werden dafür die Lines in Edges einer DCEL umgewandelt und in einer Liste dynamischer Länge gespeichert. 
Die dynamische Länge dieser Liste ist hierbei wichtig, da die Anzahl der Edges im Nachhinein variiert wird.
\begin{code}
	1	private void processData(ArrayList<Line> ls) {
		2		for (Line l : ls) {
			3			edges.add(
			4	 		new Edge(createNode(l.getP1()), 
			5	 		createNode(l.getP2())));
			6		}
		7	}

\end{code}
Die Edges werden während dieses Vorgangs aus je zwei Nodes erstellt, welche später zum Referenzieren der Edges verwendet werden.
\subsection{Twin-Edge Generierung}
Um aus diesen Edges die invertierten Gegenstücke, auch als Zwilingsedges bezeichnet, zu erhalten, werden alle Edges, die in der Liste bereits vorhanden sind, betrachtet und neue Edges hinzugefügt, deren erste Node je der zweiten Node ihrer Zwillingskante entspricht.
Hier ist zu beachten, dass man nicht nach jedem Hinzufügen einer neuen Edge von neuem die Länge der Liste von Edges betrachtet, da man so in eine endlose Schleife gerät. 
Um diesen Umstand zu vermeiden wird also zu Beginn der Verarbeitung die ursprüngliche Länge der Liste festgehalten und nur für diese Einträge ein Hinzufügen von Zwillingsedges durchgeführt.
Direkt nach dem Hinzufügen der neuen Edge wird zusätzlich noch eine Referenz erstellt, die in beiden Edges auf den jeweils zugehörigen Zwilling verweist. 
Diese Referenz dient im folgenden Prozess zur Ermittlung der Winkel zwischen den Edges, welche anschließend verwendet werden, um jeder Edge einen Vorgänger und einen Nachfolger zuzuweisen.
\begin{code}
	1	private void processData(ArrayList<Line> ls) {
		2		for (Line l : ls) {
			3			edges.add(
			4	 		new Edge(createNode(l.getP1()), 
			5	 		createNode(l.getP2())));
			6		}
		7	}
	
\end{code}
Die Edges werden während dieses Vorgangs aus je zwei Nodes erstellt, welche später zum Referenzieren der Edges verwendet werden. 
\subsection{Nachfolger- und Vorgängerermittlung}
\subsubsection{Winkelberechnung an den Knoten}
\subsubsection{Setzen der Referenzen}

\subsection{Flächenerstellung}

\subsection{Vervollständigung der Knoten}

\section{Aufbau der Einzelbauteile}
\subsection{OpenSCAD Java Interface}
\subsection{Corner}
\subsection{Wall}
\subsection{BasePlate}

\section{Druck}
\subsection{\todo{asdf}}

